<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dashboard - SecureDrop</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <!-- Hamburger Navbar -->
  <nav class="navbar">
    <div class="navbar-container">
      <div class="navbar-header">
        <h2 class="navbar-title">SecureDrop</h2>
        <button class="hamburger" id="hamburger" aria-label="Toggle menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      <div class="navbar-menu" id="navbarMenu">
        <a href="#" class="nav-item" id="navHome" onclick="showDashboard(); return false;">
          Dashboard
        </a>
        <a href="#" class="nav-item" id="navUpload" onclick="showUpload(); return false;">
          Upload
        </a>
        <a href="#" class="nav-item" id="navFiles" onclick="showFiles(); return false;">
          <span>üìÅ</span> My Files
        </a>
        <a href="#" class="nav-item" id="navChat" onclick="showChat(); return false;">
          <span>üí¨</span> Chat
        </a>
        <div class="nav-item nav-item-collapsible" id="navCollapsible" onclick="toggleCollapsible(); return false;">
          Settings
          <span class="arrow">‚ñº</span>
        </div>
        <div class="submenu" id="submenu">
          <a href="#" class="nav-item submenu-item" onclick="showRecipient(); return false;">
            Recipient
          </a>
          <a href="#" class="nav-item submenu-item" onclick="showPin(); return false;">
            Pin
          </a>
          <a href="#" class="nav-item submenu-item" onclick="showSend(); return false;">
            Send
          </a>
        </div>
        <a href="/logout" class="nav-item nav-item-logout">
          Logout
        </a>
      </div>
    </div>
  </nav>

  <!-- User Private Key Display (Top Corner) -->
  <div id="userPrivateKeyDisplay" style="position:fixed;top:70px;right:10px;background:#fff;padding:12px;border:2px solid #4caf50;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);max-width:500px;max-height:calc(100vh - 90px);overflow-y:auto;z-index:1001;display:none;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <strong style="color:#4caf50">üîë Key Management</strong>
      <button onclick="togglePrivateKeyDisplay()" style="background:none;border:none;cursor:pointer;font-size:18px">√ó</button>
    </div>
    
    <!-- Key Management Options -->
    <div style="margin-bottom:12px;padding:8px;background:#f9fafb;border-radius:4px;border:1px solid #e5e7eb">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:8px">
        <input type="radio" name="keyMode" value="auto" id="keyModeAuto" checked onchange="toggleKeyInputMode()" />
        <span>Auto-generate keys</span>
      </label>
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
        <input type="radio" name="keyMode" value="manual" id="keyModeManual" onchange="toggleKeyInputMode()" />
        <span>Enter keys manually</span>
      </label>
    </div>

    <!-- Auto-generate mode -->
    <div id="autoKeyMode" style="display:block">
      <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Your Private Key:</label>
      <textarea id="userPrivateKeyText" readonly style="width:100%;height:150px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:none;word-break:break-all" placeholder="Your private key will appear here"></textarea>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button onclick="copyPrivateKey()" style="padding:6px 12px;background:#4caf50;color:white;border:none;border-radius:4px;cursor:pointer">Copy Private Key</button>
        <button onclick="generateNewKeyPair(event)" style="padding:6px 12px;background:#f59e0b;color:white;border:none;border-radius:4px;cursor:pointer">Generate New Keys</button>
        <button onclick="copyPublicKey()" style="padding:6px 12px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer">Copy Public Key</button>
      </div>
    </div>

    <!-- Manual input mode -->
    <div id="manualKeyMode" style="display:none">
      <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Private Key (paste here):</label>
      <textarea id="manualPrivateKey" placeholder="Paste your private key here" style="width:100%;height:120px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical;word-break:break-all"></textarea>
      
      <label style="font-size:0.9em;color:#666;display:block;margin-top:12px;margin-bottom:4px">Public Key (paste here):</label>
      <textarea id="manualPublicKey" placeholder="Paste your public key here" style="width:100%;height:120px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical;word-break:break-all"></textarea>
      
      <button onclick="saveManualKeys()" style="margin-top:12px;padding:8px 16px;background:#4caf50;color:white;border:none;border-radius:4px;cursor:pointer;width:100%">Save Manual Keys</button>
    </div>

    <!-- PIN Generator -->
    <div style="margin-top:16px;padding:12px;background:#fef3c7;border-radius:4px;border:1px solid #fbbf24">
      <label style="font-size:0.9em;color:#666;display:block;margin-bottom:8px"><strong>üî¢ Generate 4-Digit PIN:</strong></label>
      <div style="display:flex;gap:8px;align-items:center">
        <input type="text" id="generatedPIN" readonly style="flex:1;padding:8px;font-size:18px;font-weight:bold;text-align:center;border:1px solid #ddd;border-radius:4px;letter-spacing:4px" placeholder="0000" />
        <button onclick="generateRandomPIN()" style="padding:8px 16px;background:#f59e0b;color:white;border:none;border-radius:4px;cursor:pointer">Generate</button>
        <button onclick="copyPIN()" style="padding:8px 16px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer">Copy</button>
      </div>
      <p class="muted small" style="margin-top:8px;font-size:0.75em">Use this for legacy AES-encrypted messages or file transfers</p>
    </div>
  </div>

  <main class="card" style="max-width:900px;margin:28px auto;margin-top:80px">
    <header style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px">
      <div>
        <h2 id="pageTitle">Dashboard</h2>
        <p class="small muted" id="welcomeText">Welcome!</p>
      </div>
      <button onclick="togglePrivateKeyDisplay()" style="padding:8px 16px;background:#4caf50;color:white;border:none;border-radius:4px;cursor:pointer">
        üîë Show Private Key
      </button>
    </header>

    <!-- Dashboard Content -->
    <div id="dashboardContent" style="display:none;">
      <div id="loading" class="muted">Loading...</div>
      
      <div id="dashboardMain" style="display:none;">
        <div style="margin-bottom:24px">
          <h3>Pending Files</h3>
          <div id="pendingFiles" class="file-list">
            <p class="muted small">No pending files.</p>
          </div>
        </div>

        <div>
          <h3>Approved Files</h3>
          <div id="approvedFiles" class="file-list">
            <p class="muted small">No approved files.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Upload Section -->
    <div id="uploadContent" style="display:none;">
      <h3>Upload File</h3>
      <form id="uploadForm" class="form" enctype="multipart/form-data">
        <label>Receiver username
          <input name="receiver" id="receiverInput" required />
        </label>
        <label>Receiver 4-digit PIN
          <input name="pin" id="pinInput" required pattern="\d{4}" title="4 digits" />
        </label>
        <label>Sender name (optional)
          <input name="sender" id="senderInput" placeholder="Anonymous" />
          </label>
        <label>File
          <input type="file" name="file" id="fileInput" required />
          </label>
        <div class="form-row">
          <button class="btn primary" type="submit">Upload</button>
          <div id="uploadMsg" class="muted small"></div>
        </div>
        </form>
    </div>

    <!-- My Files Section -->
    <div id="filesContent" style="display:none;">
      <h3>All My Files</h3>
      <div id="allFilesList" class="file-list">
        <p class="muted small">Loading files...</p>
      </div>
    </div>

    <!-- Recipient Section -->
    <div id="recipientContent" style="display:none;">
      <h3>Recipient Management</h3>
      <div class="card" style="padding:20px;margin-top:16px">
        <div style="margin-bottom:20px">
          <h4 style="margin-bottom:8px">Your Information</h4>
          <p class="muted small" id="recipientInfo"></p>
        </div>
        
        <div style="margin-top:24px">
          <h4 style="margin-bottom:12px">Recipients You've Sent Files To</h4>
          <div id="recipientsList" class="file-list" style="min-height:100px">
            <p class="muted small">Loading recipients...</p>
          </div>
        </div>
      </div>
      </div>

    <!-- Pin Section -->
    <div id="pinContent" style="display:none;">
      <h3>PIN Management</h3>
      <div class="card" style="padding:20px;margin-top:16px">
        <label>Your 4-digit PIN
          <input type="text" id="pinDisplay" readonly style="font-size:24px;text-align:center;letter-spacing:8px;font-weight:bold" />
          </label>
        <button class="btn primary" onclick="changePin()" style="margin-top:12px">Change PIN</button>
        <div id="pinMsg" class="muted small" style="margin-top:12px"></div>
      </div>
  </div>

    <!-- Send Section -->
    <div id="sendContent" style="display:none;">
      <h3>Send File</h3>
      <form id="sendForm" class="form">
        <label>Recipient Username
          <input name="recipient" id="sendRecipient" required />
        </label>
        <label>Recipient PIN
          <input name="recipientPin" id="sendPin" required pattern="\d{4}" />
        </label>
        <label>Select File to Send
          <input type="file" name="sendFile" id="sendFileInput" required />
        </label>
        <label>Your Name (optional)
          <input name="yourName" id="yourNameInput" placeholder="Anonymous" />
        </label>
        <div class="form-row">
          <button class="btn primary" type="submit">Send File</button>
          <div id="sendMsg" class="muted small"></div>
        </div>
      </form>
    </div>

    <!-- Chat Section -->
    <div id="chatContent" style="display:none;">
      <div style="display:flex;gap:20px;height:600px">
        <!-- Conversations List -->
        <div style="width:300px;border-right:1px solid #eee;padding-right:16px;overflow-y:auto">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
            <h3 style="margin:0">Conversations</h3>
            <button class="btn primary" onclick="showNewChat()" style="padding:6px 12px">+ New</button>
          </div>
          <div id="conversationsList">
            <p class="muted small">Loading conversations...</p>
          </div>
        </div>
        
        <!-- Chat Area -->
        <div style="flex:1;display:flex;flex-direction:column">
          <div id="chatHeader" style="border-bottom:1px solid #eee;padding-bottom:12px;margin-bottom:16px">
            <h3 id="chatWithUser" style="margin:0">Select a conversation</h3>
            <p class="muted small" id="chatStatus">Choose a conversation from the list</p>
          </div>
          
          <div id="chatMessages" style="flex:1;overflow-y:auto;padding:16px;background:#f9fafb;border-radius:8px;margin-bottom:16px;min-height:400px">
            <p class="muted small" style="text-align:center">No conversation selected</p>
          </div>
          
          <div id="chatInputArea" style="display:none">
            <!-- Sending Section -->
            <div style="margin-bottom:16px;padding:12px;background:#f9fafb;border-radius:8px;border:1px solid #e5e7eb">
              <h4 style="margin:0 0 12px 0;font-size:14px;color:#374151">üì§ Sending Messages</h4>
              <div style="margin-bottom:12px">
                <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Your Private Key (for signing/verification):</label>
                <textarea id="senderPrivateKey" placeholder="Paste your private key here" style="width:100%;height:80px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical"></textarea>
            </div>
              <div style="margin-bottom:12px">
                <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Recipient's Public Key (for encryption):</label>
                <textarea id="recipientPublicKey" placeholder="Paste recipient's public key here" style="width:100%;height:80px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical"></textarea>
              </div>
              <p class="muted small" style="margin-top:4px;font-size:0.8em">
                üîí Messages are encrypted with recipient's public key. Only they can decrypt with their private key.
              </p>
            </div>

            <!-- Receiving Section -->
            <div style="margin-bottom:16px;padding:12px;background:#fef3c7;border-radius:8px;border:1px solid #fbbf24">
              <h4 style="margin:0 0 12px 0;font-size:14px;color:#92400e">üì• Receiving Messages</h4>
              <div style="margin-bottom:12px">
                <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Sender's Public Key (for verification):</label>
                <textarea id="senderPublicKey" placeholder="Paste sender's public key here" style="width:100%;height:80px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical"></textarea>
              </div>
              <div style="margin-bottom:12px">
                <label style="font-size:0.9em;color:#666;display:block;margin-bottom:4px">Your Private Key (for decryption):</label>
                <textarea id="receiverPrivateKey" placeholder="Paste your private key here" style="width:100%;height:80px;font-family:monospace;font-size:11px;padding:8px;border:1px solid #ddd;border-radius:4px;resize:vertical"></textarea>
              </div>
              <div style="display:flex;gap:8px;margin-bottom:8px;position:relative;z-index:10">
                <button onclick="reloadChatMessages()" style="flex:1;padding:8px 16px;background:#3b82f6;color:white;border:none;border-radius:4px;cursor:pointer;font-size:14px;position:relative;z-index:10" type="button">
                  üîÑ Reload & Decrypt Messages
                </button>
              </div>
              <p class="muted small" style="margin-top:4px;font-size:0.8em">
                üîì Paste your private key and click "Reload & Decrypt" to decrypt received messages. Messages were encrypted with your public key.
              </p>
            </div>


            <form id="chatForm" style="display:flex;gap:8px">
              <input type="text" id="chatMessageInput" placeholder="Type a message..." style="flex:1;padding:10px;border:1px solid #ddd;border-radius:8px" required />
              <button type="submit" class="btn primary">Send</button>
            </form>
          </div>
        </div>
      </div>
    </div>
  </main>

  <style>
    /* Hamburger Navbar Styles */
    .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--card);
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      padding: 0;
    }
    .navbar-container {
      max-width: 100%;
      margin: 0 auto;
      padding: 0 20px;
    }
    .navbar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
    }
    .navbar-title {
      margin: 0;
      font-size: 20px;
      color: var(--accent);
    }
    .hamburger {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      width: 30px;
      height: 30px;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      z-index: 10;
    }
    .hamburger span {
      width: 30px;
      height: 3px;
      background: var(--accent);
      border-radius: 3px;
      transition: all 0.3s ease;
      transform-origin: center;
    }
    .hamburger.active span:nth-child(1) {
      transform: rotate(45deg) translate(8px, 8px);
    }
    .hamburger.active span:nth-child(2) {
      opacity: 0;
    }
    .hamburger.active span:nth-child(3) {
      transform: rotate(-45deg) translate(8px, -8px);
    }
    .navbar-menu {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: var(--card);
      border-top: 1px solid #eee;
    }
    .navbar-menu.active {
      max-height: 600px;
    }
    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      color: #0f172a;
      text-decoration: none;
      border-bottom: 1px solid #f0f3fb;
      cursor: pointer;
      transition: background 0.2s;
      gap: 10px;
    }
    .nav-item:hover {
      background: #f5f7fb;
    }
    .nav-item.active {
      background: #eef2ff;
      color: var(--accent);
      font-weight: 600;
    }
    .nav-item span:first-child {
      font-size: 18px;
      width: 24px;
      text-align: center;
    }
    .nav-item-collapsible {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .nav-item-collapsible .arrow {
      transition: transform 0.3s ease;
      font-size: 12px;
    }
    .nav-item-collapsible.active .arrow {
      transform: rotate(180deg);
    }
    .submenu {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: #f9fafb;
    }
    .submenu.active {
      max-height: 200px;
    }
    .submenu-item {
      padding-left: 48px !important;
      font-size: 14px;
    }
    .nav-item-logout {
      border-top: 2px solid #eee;
      margin-top: 8px;
      color: var(--danger);
    }
    .nav-item-logout:hover {
      background: #fee;
    }

    /* File List Styles */
    .file-list {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 12px;
      margin-top: 12px;
    }
    .file-item {
      padding: 12px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-item:last-child {
      border-bottom: none;
    }
    .file-info {
      flex: 1;
    }
    .file-name {
      font-weight: 500;
      margin-bottom: 4px;
    }
    .file-meta {
      font-size: 0.875em;
      color: #666;
    }
    .file-actions {
      display: flex;
      gap: 8px;
    }

    @media (min-width: 768px) {
      .hamburger {
        display: none;
      }
      .navbar-menu {
        max-height: none;
        display: flex;
        border-top: none;
        gap: 0;
      }
      .navbar-menu.active {
        max-height: none;
      }
      .nav-item {
        border-bottom: none;
        border-right: 1px solid #f0f3fb;
        white-space: nowrap;
      }
      .nav-item:last-child {
        border-right: none;
        margin-left: auto;
      }
      .submenu {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--card);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        z-index: 100;
      }
      .nav-item-collapsible {
        position: relative;
      }
    }
  </style>

<script>
    let currentUser = null;
    let userData = null;

    // Hamburger menu toggle
    document.getElementById('hamburger').addEventListener('click', function() {
      const hamburger = this;
      const menu = document.getElementById('navbarMenu');
      hamburger.classList.toggle('active');
      menu.classList.toggle('active');
    });

    // Toggle collapsible menu
    function toggleCollapsible() {
      const collapsible = document.getElementById('navCollapsible');
      const submenu = document.getElementById('submenu');
      collapsible.classList.toggle('active');
      submenu.classList.toggle('active');
    }

    // Navigation functions
    function hideAllSections() {
      document.getElementById('dashboardContent').style.display = 'none';
      document.getElementById('uploadContent').style.display = 'none';
      document.getElementById('filesContent').style.display = 'none';
      document.getElementById('recipientContent').style.display = 'none';
      document.getElementById('pinContent').style.display = 'none';
      document.getElementById('sendContent').style.display = 'none';
      document.getElementById('chatContent').style.display = 'none';
      
      // Remove active class from all nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
    }

    function showDashboard() {
      hideAllSections();
      document.getElementById('dashboardContent').style.display = 'block';
      document.getElementById('navHome').classList.add('active');
      document.getElementById('pageTitle').textContent = 'Dashboard';
      loadDashboardData();
    }

    function showUpload() {
      hideAllSections();
      document.getElementById('uploadContent').style.display = 'block';
      document.getElementById('navUpload').classList.add('active');
      document.getElementById('pageTitle').textContent = 'Upload File';
    }

    function showFiles() {
      hideAllSections();
      document.getElementById('filesContent').style.display = 'block';
      document.getElementById('navFiles').classList.add('active');
      document.getElementById('pageTitle').textContent = 'My Files';
      loadAllFiles();
    }

    function showRecipient() {
      hideAllSections();
      document.getElementById('recipientContent').style.display = 'block';
      document.getElementById('pageTitle').textContent = 'Recipient Management';
      loadRecipientInfo();
    }

    function showPin() {
      hideAllSections();
      document.getElementById('pinContent').style.display = 'block';
      document.getElementById('pageTitle').textContent = 'PIN Management';
      loadPin();
    }

    function showSend() {
      hideAllSections();
      document.getElementById('sendContent').style.display = 'block';
      document.getElementById('pageTitle').textContent = 'Send File';
    }

    function showChat() {
      hideAllSections();
      document.getElementById('chatContent').style.display = 'block';
      document.getElementById('navChat').classList.add('active');
      document.getElementById('pageTitle').textContent = 'Chat';
      loadConversations();
    }

    // User's key pair (loaded from server)
    let userPrivateKey = null;
    let userPublicKey = null;
    
    // Load user's RSA key pair from server
    async function loadUserKeys() {
      try {
        const response = await fetch('/api/user-keys', { credentials: 'same-origin' });
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || 'Failed to load user keys. Status: ' + response.status);
        }
        const data = await response.json();
        
        if (!data.privateKey || !data.publicKey) {
          throw new Error('Invalid key data received from server');
        }
        
        userPrivateKey = data.privateKey;
        userPublicKey = data.publicKey;
        
        // Display private key in UI (only if auto mode)
        if (document.getElementById('keyModeAuto')?.checked !== false) {
          document.getElementById('userPrivateKeyText').value = userPrivateKey;
        }
        
        // Auto-fill manual key inputs if in manual mode and not already filled
        if (document.getElementById('keyModeManual')?.checked) {
          if (!document.getElementById('manualPrivateKey').value) {
            document.getElementById('manualPrivateKey').value = userPrivateKey;
          }
          if (!document.getElementById('manualPublicKey').value) {
            document.getElementById('manualPublicKey').value = userPublicKey;
          }
        } else {
          // Auto-fill private key fields if not already filled (auto mode)
          if (!document.getElementById('senderPrivateKey').value) {
            document.getElementById('senderPrivateKey').value = userPrivateKey;
          }
          if (!document.getElementById('receiverPrivateKey').value) {
            document.getElementById('receiverPrivateKey').value = userPrivateKey;
          }
        }
        
        console.log('User keys loaded successfully');
      } catch (error) {
        console.error('Error loading user keys:', error);
        throw error;
      }
    }

    // Toggle private key display
    function togglePrivateKeyDisplay() {
      const display = document.getElementById('userPrivateKeyDisplay');
      display.style.display = display.style.display === 'none' ? 'block' : 'none';
    }

    // Copy private key to clipboard
    async function copyPrivateKey() {
      const keyText = document.getElementById('userPrivateKeyText').value;
      if (!keyText) {
        alert('No private key to copy');
        return;
      }
      try {
        await navigator.clipboard.writeText(keyText);
        alert('Private key copied to clipboard!');
      } catch (error) {
        // Fallback for older browsers
        document.getElementById('userPrivateKeyText').select();
        document.execCommand('copy');
        alert('Private key copied to clipboard!');
      }
    }

    // Copy public key to clipboard
    async function copyPublicKey() {
      if (!userPublicKey) {
        alert('No public key available');
        return;
      }
      try {
        await navigator.clipboard.writeText(userPublicKey);
        alert('Public key copied to clipboard!');
      } catch (error) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = userPublicKey;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Public key copied to clipboard!');
      }
    }

    // Toggle between auto and manual key input mode
    function toggleKeyInputMode() {
      const autoMode = document.getElementById('keyModeAuto').checked;
      const autoDiv = document.getElementById('autoKeyMode');
      const manualDiv = document.getElementById('manualKeyMode');
      
      if (autoMode) {
        autoDiv.style.display = 'block';
        manualDiv.style.display = 'none';
      } else {
        autoDiv.style.display = 'none';
        manualDiv.style.display = 'block';
      }
    }

    // Save manually entered keys
    async function saveManualKeys() {
      const privateKey = document.getElementById('manualPrivateKey').value.trim();
      const publicKey = document.getElementById('manualPublicKey').value.trim();
      
      if (!privateKey || !publicKey) {
        alert('Please enter both private and public keys');
        return;
      }
      
      // Validate key format (basic check)
      if (!privateKey.includes('BEGIN PRIVATE KEY') && !privateKey.includes('BEGIN RSA PRIVATE KEY')) {
        if (!confirm('Private key format may be incorrect. Continue anyway?')) {
          return;
        }
      }
      
      if (!publicKey.includes('BEGIN PUBLIC KEY')) {
        if (!confirm('Public key format may be incorrect. Continue anyway?')) {
          return;
        }
      }
      
      try {
        // Update local variables
        userPrivateKey = privateKey;
        userPublicKey = publicKey;
        
        // Update UI fields
        document.getElementById('userPrivateKeyText').value = privateKey;
        document.getElementById('senderPrivateKey').value = privateKey;
        document.getElementById('receiverPrivateKey').value = privateKey;
        
        // Save to server (optional - for persistence)
        try {
          const response = await fetch('/api/update-public-key', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ publicKey: publicKey })
          });
          
          if (response.ok) {
            console.log('Public key saved to server');
          }
        } catch (e) {
          console.warn('Could not save public key to server:', e);
        }
        
        alert('Keys saved successfully!');
        togglePrivateKeyDisplay(); // Close the dialog
      } catch (error) {
        console.error('Error saving keys:', error);
        alert('Error saving keys: ' + error.message);
      }
    }

    // Generate random 4-digit PIN
    function generateRandomPIN() {
      // Generate a random 4-digit number (1000-9999)
      const pin = Math.floor(1000 + Math.random() * 9000).toString();
      document.getElementById('generatedPIN').value = pin;
    }

    // Copy generated PIN
    async function copyPIN() {
      const pin = document.getElementById('generatedPIN').value;
      if (!pin) {
        alert('Generate a PIN first');
        return;
      }
      try {
        await navigator.clipboard.writeText(pin);
        alert('PIN copied to clipboard!');
      } catch (error) {
        // Fallback for older browsers
        document.getElementById('generatedPIN').select();
        document.execCommand('copy');
        alert('PIN copied to clipboard!');
      }
    }

    // Generate new key pair
    async function generateNewKeyPair(event) {
      if (!confirm('Generate a new key pair? This will replace your existing keys and you won\'t be able to decrypt old messages encrypted with the old keys!')) {
        return;
      }
      
      // Get button element
      const button = event && event.target ? event.target : document.querySelector('button[onclick*="generateNewKeyPair"]');
      const originalText = button ? button.textContent : 'Generate New Keys';
      
      try {
        // Show loading state
        if (button) {
          button.textContent = 'Generating...';
          button.disabled = true;
        }
        
        // Request server to generate new keys
        const response = await fetch('/api/user-keys', { 
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin' 
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(errorData.error || 'Failed to generate new keys');
        }
        
        const data = await response.json();
        
        if (!data.privateKey || !data.publicKey) {
          throw new Error('Invalid key pair received from server');
        }
        
        // Update local variables
        userPrivateKey = data.privateKey;
        userPublicKey = data.publicKey;
        
        // Update UI
        if (document.getElementById('keyModeAuto')?.checked !== false) {
          document.getElementById('userPrivateKeyText').value = userPrivateKey;
        }
        document.getElementById('senderPrivateKey').value = userPrivateKey;
        document.getElementById('receiverPrivateKey').value = userPrivateKey;
        
        // Also update manual inputs if visible
        if (document.getElementById('keyModeManual')?.checked) {
          document.getElementById('manualPrivateKey').value = userPrivateKey;
          document.getElementById('manualPublicKey').value = userPublicKey;
        }
        
        // Restore button
        if (button) {
          button.textContent = originalText;
          button.disabled = false;
        }
        
        alert('New key pair generated successfully!');
      } catch (error) {
        console.error('Error generating new keys:', error);
        alert('Failed to generate new keys: ' + error.message + '\n\nPlease check:\n- You are logged in\n- Server is running and restarted\n- Check browser console for details');
        
        // Restore button on error
        if (button) {
          button.textContent = originalText;
          button.disabled = false;
        }
      }
    }
    
    // Convert PEM format to ArrayBuffer for Web Crypto API
    function pemToArrayBuffer(pem) {
      // Handle both public and private keys
      const base64 = pem
        .replace(/-----BEGIN PUBLIC KEY-----/g, '')
        .replace(/-----END PUBLIC KEY-----/g, '')
        .replace(/-----BEGIN PRIVATE KEY-----/g, '')
        .replace(/-----END PRIVATE KEY-----/g, '')
        .replace(/-----BEGIN RSA PRIVATE KEY-----/g, '')
        .replace(/-----END RSA PRIVATE KEY-----/g, '')
        .replace(/\s/g, '');
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // Client-side RSA encryption using Web Crypto API
    // RSA-OAEP can encrypt max ~214 bytes per chunk for 2048-bit keys
    const RSA_MAX_CHUNK_SIZE = 214; // bytes per chunk
    
    // Encrypt message with recipient's public key (client-side)
    async function encryptMessageClient(message, recipientPublicKeyPem) {
      try {
        if (!recipientPublicKeyPem) {
          throw new Error('Recipient public key is required');
        }
        
        // Import the recipient's public key
        const keyData = pemToArrayBuffer(recipientPublicKeyPem);
        const recipientPublicKey = await crypto.subtle.importKey(
          'spki',
          keyData,
          {
            name: 'RSA-OAEP',
            hash: 'SHA-256'
          },
          false,
          ['encrypt']
        );
        
        const encoder = new TextEncoder();
        const messageBuffer = encoder.encode(message);
        const chunks = [];
        
        // Split message into chunks if it's too large
        for (let i = 0; i < messageBuffer.length; i += RSA_MAX_CHUNK_SIZE) {
          const chunk = messageBuffer.slice(i, i + RSA_MAX_CHUNK_SIZE);
          
          const encryptedChunk = await crypto.subtle.encrypt(
            {
              name: 'RSA-OAEP'
            },
            recipientPublicKey,
            chunk
          );
          
          // Convert to base64 for JSON transport
          const base64Chunk = btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedChunk)));
          chunks.push(base64Chunk);
        }
        
        return {
          encryptedData: chunks,
          algorithm: 'RSA-OAEP-2048',
          format: 'rsa-e2e'
        };
      } catch (e) {
        console.error('RSA encryption error:', e);
        throw e;
      }
    }

    // Decrypt message with user's private key (client-side)
    async function decryptMessageClient(encryptedObj, privateKeyPem) {
      try {
        if (!privateKeyPem || privateKeyPem.trim() === '') {
          throw new Error('Private key is required for decryption');
        }
        
        if (!encryptedObj || typeof encryptedObj !== 'object') {
          throw new Error('Invalid encrypted message object');
        }
        
        if (!encryptedObj.encryptedData || !Array.isArray(encryptedObj.encryptedData)) {
          throw new Error('Invalid encrypted message format - encryptedData must be an array');
        }
        
        if (encryptedObj.encryptedData.length === 0) {
          throw new Error('Invalid encrypted message - no encrypted chunks found');
        }
        
        // Validate private key format
        if (!privateKeyPem.includes('BEGIN PRIVATE KEY') && !privateKeyPem.includes('BEGIN RSA PRIVATE KEY')) {
          throw new Error('Invalid private key format - must be PEM format');
        }
        
        // Import the private key
        let keyData;
        try {
          keyData = pemToArrayBuffer(privateKeyPem);
        } catch (e) {
          throw new Error('Failed to parse private key: ' + (e.message || 'Invalid format'));
        }
        
        let privateKey;
        try {
          privateKey = await crypto.subtle.importKey(
            'pkcs8',
            keyData,
            {
              name: 'RSA-OAEP',
              hash: 'SHA-256'
            },
          false,
          ['decrypt']
        );
        } catch (e) {
          throw new Error('Failed to import private key: ' + (e.message || 'Invalid key format'));
        }
        
        const decryptedChunks = [];
        
        // Decrypt each chunk
        for (let i = 0; i < encryptedObj.encryptedData.length; i++) {
          const encryptedChunkBase64 = encryptedObj.encryptedData[i];
          
          if (!encryptedChunkBase64 || typeof encryptedChunkBase64 !== 'string') {
            throw new Error(`Invalid encrypted chunk at index ${i}`);
          }
          
          // Convert base64 to ArrayBuffer
          let binaryString;
          try {
            binaryString = atob(encryptedChunkBase64);
          } catch (e) {
            throw new Error(`Invalid base64 in chunk ${i}: ${e.message || 'Invalid format'}`);
          }
          
          const bytes = new Uint8Array(binaryString.length);
          for (let j = 0; j < binaryString.length; j++) {
            bytes[j] = binaryString.charCodeAt(j);
          }
          
          let decryptedChunk;
          try {
            decryptedChunk = await crypto.subtle.decrypt(
              {
                name: 'RSA-OAEP'
              },
              privateKey,
              bytes.buffer
            );
          } catch (e) {
            // More specific error for decryption failures
            if (e.name === 'OperationError' || e.message?.includes('decrypt')) {
              throw new Error('Decryption failed - private key does not match the public key used for encryption. Chunk: ' + i);
            }
            throw new Error(`Failed to decrypt chunk ${i}: ${e.message || e.toString()}`);
          }
          
          decryptedChunks.push(decryptedChunk);
        }
        
        // Combine all decrypted chunks
        const totalLength = decryptedChunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);
        const fullMessage = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of decryptedChunks) {
          fullMessage.set(new Uint8Array(chunk), offset);
          offset += chunk.byteLength;
        }
        
        // Convert to string
        const decoder = new TextDecoder();
        const result = decoder.decode(fullMessage);
        
        if (!result || result.trim() === '') {
          throw new Error('Decryption resulted in empty message');
        }
        
        return result;
      } catch (e) {
        console.error('RSA decryption error:', e);
        console.error('Error details:', {
          name: e.name,
          message: e.message,
          stack: e.stack
        });
        // Re-throw with better error message
        const errorMsg = e.message || e.name || e.toString() || 'Unknown decryption error';
        throw new Error(errorMsg);
      }
    }

    let currentChatRecipient = null;
    let chatPollInterval = null;

    // Reload chat messages function (for manual reload after pasting keys)
    async function reloadChatMessages() {
      console.log('reloadChatMessages called');
      if (!currentChatRecipient) {
        alert('Please select a conversation first');
        return;
      }
      
      // Show loading indicator
      const messagesDiv = document.getElementById('chatMessages');
      if (!messagesDiv) {
        console.error('chatMessages div not found');
        return;
      }
      const originalContent = messagesDiv.innerHTML;
      messagesDiv.innerHTML = '<p class="muted small" style="text-align:center">üîÑ Reloading and decrypting messages...</p>';
      
      try {
        await loadChatMessages(currentChatRecipient);
      } catch (error) {
        console.error('Error reloading messages:', error);
        messagesDiv.innerHTML = '<p class="error" style="text-align:center;color:#f44336">Error reloading messages: ' + error.message + '</p>';
      }
    }
    
    // Helper function to attach reload button event listener
    function attachReloadButtonListener() {
      const reloadBtn = document.querySelector('button[onclick="reloadChatMessages()"]');
      if (reloadBtn && !reloadBtn.hasAttribute('data-listener-attached')) {
        reloadBtn.setAttribute('data-listener-attached', 'true');
        // Keep onclick as backup, but also add event listener
        reloadBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('Reload button clicked via event listener');
          reloadChatMessages();
        }, { capture: true });
      }
    }
    
    // Add event listener for reload button when chat opens
    document.addEventListener('DOMContentLoaded', function() {
      // Try to attach event listener after page loads
      setTimeout(attachReloadButtonListener, 500);
    });

    // Load conversations list
    async function loadConversations() {
      try {
        const r = await fetch('/api/chat/conversations', { credentials: 'same-origin' });
        if (!r.ok) {
          const error = await r.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to load conversations');
        }
        const conversations = await r.json();
        
        const listDiv = document.getElementById('conversationsList');
        
        if (conversations && conversations.length > 0) {
          listDiv.innerHTML = conversations.map(conv => `
            <div class="file-item" style="cursor:pointer;margin-bottom:8px" onclick="openChat('${conv.username}')">
              <div class="file-info">
                <div class="file-name">${conv.username}${!conv.userExists ? ' <span style="color:#f59e0b;font-size:0.8em">(deleted)</span>' : ''}</div>
                <div class="file-meta">${conv.lastMessage ? new Date(conv.lastMessage.time).toLocaleString() : 'No messages'}</div>
              </div>
            </div>
          `).join('');
        } else {
          listDiv.innerHTML = '<p class="muted small">No conversations yet. Start a new chat!</p>';
        }
      } catch (e) {
        console.error('Error loading conversations:', e);
        const errorMsg = e.message || 'Unknown error';
        document.getElementById('conversationsList').innerHTML = 
          '<p class="error" style="color:#f44336;padding:12px;background:#fee;border-radius:4px">Error loading conversations: ' + errorMsg + '</p>';
      }
    }

    // Open chat with a user
    async function openChat(recipient) {
      currentChatRecipient = recipient;
      document.getElementById('chatWithUser').textContent = `Chat with ${recipient}`;
      document.getElementById('chatStatus').textContent = 'End-to-end encrypted chat';
      document.getElementById('chatStatus').style.color = '';
      document.getElementById('chatInputArea').style.display = 'block';
      // Attach reload button listener when chat input area is shown
      setTimeout(attachReloadButtonListener, 100);
      
      // Load recipient's public key automatically
      try {
        const response = await fetch(`/api/user/${recipient}/public-key`, { credentials: 'same-origin' });
        if (response.ok) {
          const data = await response.json();
          // Auto-fill recipient's public key
          document.getElementById('recipientPublicKey').value = data.publicKey;
          console.log(`Loaded public key for ${recipient}`);
        } else {
          console.warn('Could not load recipient public key:', await response.json().catch(() => ({})));
        }
      } catch (error) {
        console.error('Error loading recipient public key:', error);
      }
      
      // Ensure user's own keys are loaded
      if (!userPrivateKey || !userPublicKey) {
        try {
          await loadUserKeys();
        } catch (error) {
          console.error('Error loading user keys:', error);
        }
      }
      
      // Auto-fill user's private key if not already filled
      const senderPrivateKeyInput = document.getElementById('senderPrivateKey');
      const receiverPrivateKeyInput = document.getElementById('receiverPrivateKey');
      
      if (senderPrivateKeyInput && !senderPrivateKeyInput.value && userPrivateKey) {
        senderPrivateKeyInput.value = userPrivateKey;
        console.log('Auto-filled sender private key');
      }
      if (receiverPrivateKeyInput && !receiverPrivateKeyInput.value && userPrivateKey) {
        receiverPrivateKeyInput.value = userPrivateKey;
        console.log('Auto-filled receiver private key');
      }
      
      // Log current keys for debugging
      if (userPublicKey) {
        console.log('Current user public key preview:', userPublicKey.substring(0, 100) + '...');
        console.log('IMPORTANT: Messages encrypted with a DIFFERENT public key cannot be decrypted with your current private key.');
        console.log('If you regenerated your keys, old messages will not decrypt.');
      }
      
      await loadChatMessages(recipient);
      
      // Poll for new messages every 3 seconds
      if (chatPollInterval) clearInterval(chatPollInterval);
      chatPollInterval = setInterval(() => {
        if (currentChatRecipient) loadChatMessages(currentChatRecipient);
      }, 3000);
    }

    // Load chat messages
    async function loadChatMessages(recipient) {
      try {
        const r = await fetch(`/api/chat/${recipient}`, { credentials: 'same-origin' });
        if (!r.ok) {
          const error = await r.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || 'Failed to load messages');
        }
        const data = await r.json();
        
        // Show warning if recipient doesn't exist
        if (data.warning) {
          document.getElementById('chatStatus').textContent = data.warning + ' (View-only)';
          document.getElementById('chatStatus').style.color = '#f59e0b';
        }
        
        const messagesDiv = document.getElementById('chatMessages');
        
        if (data.messages && data.messages.length > 0) {
          // Get user's PIN for decryption
          if (!userData) {
            const userR = await fetch('/api/user-data', { credentials: 'same-origin' });
            if (userR.ok) userData = await userR.json();
          }
          
          // Process messages sequentially to avoid race conditions
          const messagesHtml = [];
          for (const msg of data.messages) {
            // Check if message is from current user - compare strings carefully
            const msgFrom = String(msg.from || '').trim();
            const currentUserStr = String(currentUser || '').trim();
            
            // Critical: Determine isMine synchronously BEFORE any async operations
            const isMine = msgFrom.toLowerCase() === currentUserStr.toLowerCase();
            
            // Debug logging
            console.log('Message alignment:', { 
              msgFrom: msgFrom, 
              currentUser: currentUserStr, 
              isMine: isMine,
              willAlign: isMine ? 'RIGHT' : 'LEFT'
            });
            
            // Determine alignment and styling IMMEDIATELY (synchronously)
            // Store in constants that won't change
            const messageAlignment = isMine ? 'flex-end' : 'flex-start';
            const messageBgColor = isMine ? 'var(--accent)' : '#fff';
            const messageTextColor = isMine ? '#fff' : '#000';
            const messageSenderName = isMine ? 'You' : (msg.from || 'Unknown');
            
            let messageText = '';
            
            // Handle encrypted messages (RSA end-to-end or legacy AES format)
            if (msg.encrypted && msg.message && typeof msg.message === 'object' && msg.message.encryptedData) {
              // Check if it's RSA end-to-end format
              if (msg.message.format === 'rsa-e2e' || (Array.isArray(msg.message.encryptedData) && msg.message.algorithm === 'RSA-OAEP-2048')) {
                // RSA end-to-end - decrypt client-side with user's private key
                // IMPORTANT: In RSA, only the RECIPIENT can decrypt (they were the one who provided the public key for encryption)
                // If you're the sender, you CANNOT decrypt your own sent messages (they were encrypted with recipient's public key)
                
              if (isMine) {
                  // For messages I sent: They were encrypted with recipient's public key, so I cannot decrypt them
                  // The recipient would decrypt with their private key
                  messageText = '[Your sent message - encrypted with recipient\'s public key. Only they can decrypt it.]';
                } else {
                  // For messages I received: They were encrypted with MY public key, so I can decrypt with MY private key
                  const receiverPrivateKey = document.getElementById('receiverPrivateKey').value.trim();
                  
                  if (!receiverPrivateKey) {
                    messageText = '[Encrypted - Enter your private key to decrypt]';
                  } else {
                    // Debug: Log message structure and key info
                    console.log('Attempting to decrypt message:', {
                      messageId: msg.id,
                      from: msg.from,
                      to: msg.to,
                      hasEncryptedData: !!msg.message?.encryptedData,
                      encryptedDataLength: msg.message?.encryptedData?.length,
                      format: msg.message?.format,
                      algorithm: msg.message?.algorithm,
                      privateKeyLength: receiverPrivateKey.length,
                      privateKeyPreview: receiverPrivateKey.substring(0, 50) + '...'
                    });
                    
                    try {
                      // Validate message structure before decryption
                      if (!msg.message || typeof msg.message !== 'object') {
                        throw new Error('Invalid message structure - message is not an object');
                      }
                      
                      if (!msg.message.encryptedData || !Array.isArray(msg.message.encryptedData)) {
                        throw new Error('Invalid encrypted message format - encryptedData is missing or not an array');
                      }
                      
                      if (msg.message.encryptedData.length === 0) {
                        throw new Error('Invalid encrypted message - no encrypted chunks found');
                      }
                      
                      messageText = await decryptMessageClient(msg.message, receiverPrivateKey);
                      if (!messageText || messageText.trim() === '') {
                        messageText = '[Decryption failed - check your private key]';
              } else {
                        console.log('Decryption successful for message:', msg.id);
                    }
                  } catch (e) {
                      console.error('RSA decryption error:', e);
                      console.error('Full error object:', e);
                      console.error('Message structure:', JSON.stringify(msg.message, null, 2));
                      const errorMsg = e.message || e.name || e.toString() || 'Unknown decryption error';
                      console.error('Extracted error message:', errorMsg);
                      
                      // Provide more helpful error messages
                      if (errorMsg.toLowerCase().includes('bad decrypt') || errorMsg.toLowerCase().includes('decrypt') || errorMsg.includes('OperationError') || errorMsg.includes('does not match')) {
                        messageText = '[Decryption failed - private key mismatch.\n\nPossible causes:\n1. The message was encrypted with a different public key\n2. You are using a private key that doesn\'t match the public key used for encryption\n3. The keys were regenerated after the message was sent\n\nSolution: Make sure you are using the private key that matches the public key that was active when the message was encrypted.]';
                      } else if (errorMsg.includes('Invalid') || errorMsg.includes('invalid')) {
                        messageText = '[Invalid message format - message may be corrupted. Error: ' + errorMsg + ']';
                      } else if (errorMsg.toLowerCase().includes('key') || errorMsg.toLowerCase().includes('format')) {
                        messageText = '[Invalid private key - check the key format. Make sure it includes BEGIN and END lines. Error: ' + errorMsg + ']';
                      } else if (errorMsg.includes('match')) {
                        messageText = '[Private key doesn\'t match - this key cannot decrypt messages encrypted with your public key]';
                } else {
                        messageText = '[Decryption error: ' + errorMsg + ']';
                      }
                    }
                  }
                }
              } else {
                // Legacy AES format - no longer supported, show encrypted message
                messageText = '[Old AES-encrypted message - no longer supported]';
              }
            } 
            // Handle old unencrypted messages (plain text)
            else if (msg.message) {
              if (typeof msg.message === 'string') {
                messageText = msg.message;
              } else if (msg.message.encryptedData || msg.message.iv) {
                // Legacy encrypted format (AES) - no longer supported
                messageText = '[Old AES-encrypted message - no longer supported]';
              } else {
                messageText = '[Invalid message format]';
              }
            } else {
              messageText = '[No message content]';
            }
            
            // Use the pre-determined alignment values (set synchronously)
            messagesHtml.push(`
              <div style="display:flex;justify-content:${messageAlignment};margin-bottom:12px">
                <div style="max-width:70%;padding:10px 14px;background:${messageBgColor};color:${messageTextColor};border-radius:12px;box-shadow:0 2px 4px rgba(0,0,0,0.1);word-wrap:break-word">
                  <div style="font-weight:500;font-size:0.9em;margin-bottom:4px">${messageSenderName}</div>
                  <div style="white-space:pre-wrap">${messageText}</div>
                  <div style="font-size:0.75em;opacity:0.7;margin-top:4px">${new Date(msg.time).toLocaleString()}</div>
                </div>
              </div>
            `);
          }
          
          messagesDiv.innerHTML = messagesHtml.join('');
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        } else {
          messagesDiv.innerHTML = '<p class="muted small" style="text-align:center">No messages yet. Start the conversation!</p>';
        }
      } catch (e) {
        document.getElementById('chatMessages').innerHTML = '<p class="error">Error loading messages: ' + e.message + '</p>';
      }
    }

    // Show new chat dialog
    function showNewChat() {
      const recipient = prompt('Enter recipient username:');
      if (recipient && recipient !== currentUser) {
        openChat(recipient);
      }
    }

    // Chat form handler
    document.getElementById('chatForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!currentChatRecipient) {
        alert('Please select a conversation first');
        return;
      }
      
      const messageInput = document.getElementById('chatMessageInput');
      const message = messageInput.value.trim();
      
      if (!message) {
        alert('Please enter a message');
        return;
      }
      
      try {
        // Get keys from input fields
        const senderPrivateKey = document.getElementById('senderPrivateKey').value.trim();
        const recipientPublicKey = document.getElementById('recipientPublicKey').value.trim();
        
        if (!recipientPublicKey) {
          alert('Please enter recipient\'s public key to send encrypted messages');
        return;
      }
      
        // Encrypt message client-side using recipient's public key
        let encryptedMessage;
        try {
          encryptedMessage = await encryptMessageClient(message, recipientPublicKey);
          if (!encryptedMessage || !encryptedMessage.encryptedData) {
            throw new Error('Encryption failed - invalid result');
          }
        } catch (encryptError) {
          console.error('Encryption error:', encryptError);
          alert('Encryption error: ' + encryptError.message + '\n\nPlease check:\n- Recipient\'s public key is correct\n- Public key format is valid (PEM format)');
          return;
        }
        
        const r = await fetch('/api/chat/send', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify({
            recipient: currentChatRecipient,
            message: encryptedMessage.encryptedData, // Send encrypted data array
            encrypted: true,
            encryptedFormat: 'rsa-e2e' // End-to-end RSA format
          })
        });
        
        if (!r.ok) {
          const error = await r.json();
          throw new Error(error.error || 'Failed to send message');
        }
        
        messageInput.value = '';
        await loadChatMessages(currentChatRecipient);
      } catch (err) {
        console.error('Error sending message:', err);
        alert('Error: ' + err.message);
      }
    });

    // Load dashboard data
    async function loadDashboardData(forceRefresh = false) {
      try {
        // Show loading state
        document.getElementById('loading').style.display = 'block';
        document.getElementById('dashboardMain').style.display = 'none';
        
        if (!userData || forceRefresh) {
          const r = await fetch('/api/user-data', { credentials: 'same-origin' });
          if (!r.ok) throw new Error('Failed to load user data');
          userData = await r.json();
        }

        // Display pending files
        const pendingDiv = document.getElementById('pendingFiles');
        if (userData.pending && userData.pending.length > 0) {
          pendingDiv.innerHTML = userData.pending.map(file => `
            <div class="file-item">
              <div class="file-info">
                <div class="file-name">${file.filename}</div>
                <div class="file-meta">From: ${file.sender || 'Anonymous'} ‚Ä¢ ${new Date(file.time).toLocaleString()}</div>
              </div>
              <div class="file-actions">
                <button class="btn" onclick="approveFile('${file.id}')" style="background:#4caf50;color:white">Approve</button>
                <button class="btn" onclick="rejectFile('${file.id}')" style="background:#f44336;color:white">Reject</button>
              </div>
            </div>
          `).join('');
        } else {
          pendingDiv.innerHTML = '<p class="muted small">No pending files.</p>';
        }

        // Display approved files
        const approvedDiv = document.getElementById('approvedFiles');
        if (userData.files && userData.files.length > 0) {
          approvedDiv.innerHTML = userData.files.map(file => `
            <div class="file-item">
              <div class="file-info">
                <div class="file-name">${file.filename}</div>
                <div class="file-meta">From: ${file.sender || 'Anonymous'} ‚Ä¢ ${new Date(file.time).toLocaleString()}</div>
              </div>
              <div class="file-actions">
                <a href="/api/download/${file.id}" class="btn primary">Download</a>
              </div>
            </div>
          `).join('');
        } else {
          approvedDiv.innerHTML = '<p class="muted small">No approved files.</p>';
        }

        document.getElementById('loading').style.display = 'none';
        document.getElementById('dashboardMain').style.display = 'block';
      } catch (e) {
        document.getElementById('loading').textContent = 'Error loading dashboard: ' + e.message;
      }
    }

    // Load all files
    async function loadAllFiles(forceRefresh = false) {
      try {
        if (!userData || forceRefresh) {
          const r = await fetch('/api/user-data', { credentials: 'same-origin' });
          if (!r.ok) throw new Error('Failed to load user data');
          userData = await r.json();
        }

        const allFiles = [...(userData.pending || []), ...(userData.files || [])];
        const filesDiv = document.getElementById('allFilesList');
        
        if (allFiles.length > 0) {
          filesDiv.innerHTML = allFiles.map(file => {
            const isPending = userData.pending?.some(f => f.id === file.id);
            return `
              <div class="file-item">
                <div class="file-info">
                  <div class="file-name">${file.filename} ${isPending ? '<span style="color:#f59e0b">(Pending)</span>' : ''}</div>
                  <div class="file-meta">From: ${file.sender || 'Anonymous'} ‚Ä¢ ${new Date(file.time).toLocaleString()}</div>
                </div>
                <div class="file-actions">
                  ${isPending ? 
                    `<button class="btn" onclick="approveFile('${file.id}')" style="background:#4caf50;color:white">Approve</button>
                     <button class="btn" onclick="rejectFile('${file.id}')" style="background:#f44336;color:white">Reject</button>` :
                    `<a href="/api/download/${file.id}" class="btn primary">Download</a>`
                  }
                </div>
              </div>
            `;
          }).join('');
        } else {
          filesDiv.innerHTML = '<p class="muted small">No files found.</p>';
        }
      } catch (e) {
        document.getElementById('allFilesList').innerHTML = '<p class="error">Error loading files: ' + e.message + '</p>';
      }
    }

    // Load recipient info
    async function loadRecipientInfo() {
      try {
        // Show user info
        if (!userData) {
          const r = await fetch('/api/user-data', { credentials: 'same-origin' });
          if (!r.ok) throw new Error('Failed to load user data');
          userData = await r.json();
        }
        
        const pin = userData.pin || 'Not set';
        document.getElementById('recipientInfo').textContent = 
          `Username: ${currentUser} | PIN: ${pin}\nShare this information with others to allow them to send you files.`;
        
        // Load sent files
        const sentData = await fetch('/api/sent-files', { credentials: 'same-origin' });
        if (!sentData.ok) throw new Error('Failed to load sent files');
        const sentFiles = await sentData.json();
        
        const recipientsDiv = document.getElementById('recipientsList');
        
        if (sentFiles && sentFiles.length > 0) {
          // Group by recipient
          const recipientMap = {};
          sentFiles.forEach(file => {
            if (!recipientMap[file.receiver]) {
              recipientMap[file.receiver] = [];
            }
            recipientMap[file.receiver].push(file);
          });
          
          // Display grouped recipients
          recipientsDiv.innerHTML = Object.keys(recipientMap).map(receiver => {
            const files = recipientMap[receiver];
            const fileCount = files.length;
            const lastSent = new Date(files[files.length - 1].time).toLocaleString();
            
            // Count statuses
            const approvedCount = files.filter(f => f.status === 'approved').length;
            const pendingCount = files.filter(f => f.status === 'pending').length;
            const rejectedCount = files.filter(f => f.status === 'rejected').length;
            
            return `
              <div class="file-item recipient-item" style="cursor:pointer" onclick="toggleRecipientDetails('${receiver}')">
                <div class="file-info">
                  <div class="file-name">${receiver}</div>
                  <div class="file-meta">
                    ${fileCount} file${fileCount > 1 ? 's' : ''} sent ‚Ä¢ 
                    ${approvedCount > 0 ? `<span style="color:#4caf50">${approvedCount} approved</span>` : ''}
                    ${pendingCount > 0 ? `<span style="color:#f59e0b">${pendingCount} pending</span>` : ''}
                    ${rejectedCount > 0 ? `<span style="color:#f44336">${rejectedCount} rejected</span>` : ''}
                    ‚Ä¢ Last sent: ${lastSent}
                  </div>
                  <div class="recipient-details" id="details-${receiver}" style="display:none;margin-top:12px;padding-top:12px;border-top:1px solid #eee">
                    ${files.map(file => {
                      const statusColor = file.status === 'approved' ? '#4caf50' : 
                                         file.status === 'rejected' ? '#f44336' : '#f59e0b';
                      const statusIcon = file.status === 'approved' ? '‚úì' : 
                                       file.status === 'rejected' ? '‚úó' : '‚è≥';
                      return `
                        <div style="padding:8px;background:#f9fafb;border-radius:4px;margin-bottom:8px">
                          <div style="display:flex;justify-content:space-between;align-items:center">
                            <div>
                              <strong>${file.filename}</strong>
                              <div style="font-size:0.85em;color:#666;margin-top:4px">
                                Sent: ${new Date(file.time).toLocaleString()}
                              </div>
                            </div>
                            <span style="color:${statusColor};font-weight:bold">${statusIcon} ${file.status || 'pending'}</span>
                          </div>
                        </div>
                      `;
                    }).join('')}
                  </div>
                </div>
                <div class="file-actions">
                  <span class="detail-toggle" id="toggle-${receiver}" style="color:var(--accent)">‚ñº</span>
                </div>
              </div>
            `;
          }).join('');
        } else {
          recipientsDiv.innerHTML = '<p class="muted small">You haven\'t sent any files yet. Use the Upload or Send option to send files to recipients.</p>';
        }
      } catch (e) {
        document.getElementById('recipientsList').innerHTML = '<p class="error">Error loading recipients: ' + e.message + '</p>';
        document.getElementById('recipientInfo').textContent = 
          `You can receive files from other users. Share your username "${currentUser}" and your PIN to allow others to send you files.`;
      }
    }
    
    // Toggle recipient details
    function toggleRecipientDetails(receiver) {
      const detailsDiv = document.getElementById(`details-${receiver}`);
      const toggleSpan = document.getElementById(`toggle-${receiver}`);
      
      if (detailsDiv.style.display === 'none') {
        detailsDiv.style.display = 'block';
        toggleSpan.textContent = '‚ñ≤';
      } else {
        detailsDiv.style.display = 'none';
        toggleSpan.textContent = '‚ñº';
      }
    }

    // Load PIN
    async function loadPin() {
      try {
        if (!userData) {
          const r = await fetch('/api/user-data', { credentials: 'same-origin' });
          if (!r.ok) throw new Error('Failed to load user data');
          userData = await r.json();
        }
        const pin = userData.pin || 'Not set';
        document.getElementById('pinDisplay').value = pin;
      } catch (e) {
        document.getElementById('pinMsg').textContent = 'Error loading PIN: ' + e.message;
      }
    }

    // Change PIN
    async function changePin() {
      const newPin = prompt('Enter new 4-digit PIN:');
      if (newPin && /^\d{4}$/.test(newPin)) {
        try {
          const r = await fetch('/api/update-pin', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ pin: newPin })
          });
          if (r.ok) {
            document.getElementById('pinDisplay').value = newPin;
            document.getElementById('pinMsg').textContent = 'PIN updated successfully!';
            if (userData) userData.pin = newPin;
          } else {
            throw new Error('Failed to update PIN');
          }
        } catch (e) {
          document.getElementById('pinMsg').textContent = 'Error: ' + e.message;
        }
      } else if (newPin) {
        alert('PIN must be exactly 4 digits');
      }
    }

    // Upload form handler
    document.getElementById('uploadForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const formData = new FormData();
      formData.append('receiver', document.getElementById('receiverInput').value);
      formData.append('pin', document.getElementById('pinInput').value);
      formData.append('sender', document.getElementById('senderInput').value || 'Anonymous');
      formData.append('file', document.getElementById('fileInput').files[0]);
      
      const msgDiv = document.getElementById('uploadMsg');
      msgDiv.textContent = 'Uploading...';
      
      try {
        const res = await fetch('/upload', { method: 'POST', body: formData, credentials: 'same-origin' });
        const text = await res.text();
        if (!res.ok) throw new Error(text || res.statusText);
        msgDiv.textContent = 'Success: ' + text;
        msgDiv.style.color = '#4caf50';
        e.target.reset();
      } catch (err) {
        msgDiv.textContent = 'Upload failed: ' + (err.message || err);
        msgDiv.style.color = '#f44336';
      }
    });

    // Send form handler
    document.getElementById('sendForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const formData = new FormData();
      formData.append('receiver', document.getElementById('sendRecipient').value);
      formData.append('pin', document.getElementById('sendPin').value);
      formData.append('sender', document.getElementById('yourNameInput').value || 'Anonymous');
      formData.append('file', document.getElementById('sendFileInput').files[0]);
      
      const msgDiv = document.getElementById('sendMsg');
      msgDiv.textContent = 'Sending...';
      
      try {
        const res = await fetch('/upload', { method: 'POST', body: formData, credentials: 'same-origin' });
        const text = await res.text();
        if (!res.ok) throw new Error(text || res.statusText);
        msgDiv.textContent = 'File sent successfully: ' + text;
        msgDiv.style.color = '#4caf50';
        e.target.reset();
      } catch (err) {
        msgDiv.textContent = 'Send failed: ' + (err.message || err);
        msgDiv.style.color = '#f44336';
      }
    });

    // Initialize
    (async function() {
      // Check authentication
      try {
        const r = await fetch('/api/whoami', { credentials: 'same-origin' });
        if (!r.ok) {
          window.location.href = '/login.html';
          return;
        }
        const data = await r.json();
        currentUser = data.user;
        document.getElementById('welcomeText').textContent = `Welcome, ${currentUser}!`;
      } catch (e) {
        window.location.href = '/login.html';
        return;
      }

      // Load user's key pair on initialization
      try {
        await loadUserKeys();
      } catch (error) {
        console.error('Failed to load user keys:', error);
        alert('Warning: Failed to load encryption keys. Some features may not work correctly.');
      }

      // Show dashboard by default
      showDashboard();
    })();

    async function approveFile(fileId) {
      try {
        const r = await fetch(`/api/approve/${fileId}`, { method: 'POST', credentials: 'same-origin' });
        if (!r.ok) throw new Error('Failed to approve file');
        
        // Force refresh of user data
        userData = null;
        
        // Refresh dashboard if visible
        const dashboardContent = document.getElementById('dashboardContent');
        if (dashboardContent && dashboardContent.style.display !== 'none') {
          await loadDashboardData(true);
        }
        
        // Refresh files view if visible
        const filesContent = document.getElementById('filesContent');
        if (filesContent && filesContent.style.display !== 'none') {
          await loadAllFiles(true);
        }
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }

    async function rejectFile(fileId) {
      try {
        const r = await fetch(`/api/reject/${fileId}`, { method: 'POST', credentials: 'same-origin' });
        if (!r.ok) throw new Error('Failed to reject file');
        
        // Force refresh of user data
        userData = null;
        
        // Refresh dashboard if visible
        const dashboardContent = document.getElementById('dashboardContent');
        if (dashboardContent && dashboardContent.style.display !== 'none') {
          await loadDashboardData(true);
        }
        
        // Refresh files view if visible
        const filesContent = document.getElementById('filesContent');
        if (filesContent && filesContent.style.display !== 'none') {
          await loadAllFiles(true);
        }
      } catch (e) {
        alert('Error: ' + e.message);
      }
    }
</script>
</body>
</html>
